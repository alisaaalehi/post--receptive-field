<!DOCTYPE html>
<html>
<body>

<svg id="svg" height="400" width="800">

  Sorry, your browser does not support inline SVG.
</svg>

<div style="position: absolute; top: 80px; left: 400px; text-align: right;">
Kernal Size (k1): <span id="value_k1">1</span> <input id="slider_k1" type="range" style="width: 80px;" min="1" max="3" value="1"><br />
Padding (p1, q1): <span id="value_p1">0</span> <input id="slider_p1" type="range" style="width: 80px;" min="0" max="2" value="0"><br />
Stride (s1): <span id="value_s1">1</span> <input id="slider_s1" type="range" style="width: 80px;" min="1" max="3" value="1"><br />
</div>

<div style="position: absolute; top: 230px; left: 400px; text-align: right;">
k2: <span id="value_k2">1</span> <input id="slider_k2" type="range" style="width: 80px;" min="1" max="3" value="1"><br />
p2/q2: <span id="value_p2">0</span> <input id="slider_p2" type="range" style="width: 80px;" min="0" max="1" value="0"><br />
s2: <span id="value_s2">1</span> <input id="slider_s2" type="range" style="width: 80px;" min="1" max="3" value="1"><br />
</div>

<script type="text/javascript">
var svgEl = document.getElementById("svg");
var globals = {
  "box_width": 50,
  "box_height": 50,
  "box_inner_padding": 5,
  "row_space": 100,
  "perspective_shift": 18,
  "perspective_spacing": 4,
  "stroke_width": 1
};

var renderRowFn = function(el, row, width, offset, globals) {
  var htmlStr = '';

  for (var d = 0; d >= 0; d--) {
    var xPos = offset * globals.box_width;
    var yPos = (row - 1) * (globals.box_height + globals.row_space);
    xPos += d * globals.perspective_shift;
    yPos += d * globals.perspective_shift;

    var cube_depth = globals.perspective_shift - globals.perspective_spacing;
    for (var i = 0; i < width; i++) {
      htmlStr += '<rect x="' + xPos + '" y="' + yPos + '" width="' + globals.box_width + '" height="' + globals.box_height + '" style="fill:rgb(255,255,255);stroke-width:' + globals.stroke_width + ';stroke:rgb(140,140,140)" />';
      // Draw the bottom slanted face of the cube.
      htmlStr += '<path stroke="rgb(140,140,140)" d="M' + xPos + ' ' + (yPos + globals.box_height) + ' l' + cube_depth + ' ' + cube_depth + ' l' + globals.box_width + ' 0 l-' + cube_depth + ' -' + cube_depth + ' Z" fill-opacity="null" stroke-opacity="null" stroke-width="' + globals.stroke_width + '" fill="rgb(255,255,255)"/>'
      // Draw the right side slanted face of the cube.
      htmlStr += '<path stroke="rgb(140,140,140)" d="M' + (xPos + globals.box_width) + ' ' + yPos + ' l' + cube_depth + ' ' + cube_depth + ' l0 ' + globals.box_height + ' l-' + cube_depth + ' -' + cube_depth + ' Z" fill-opacity="null" stroke-opacity="null" stroke-width="' + globals.stroke_width + '" fill="rgb(255,255,255)"/>'
      xPos += globals.box_width;
    }
  }

  el.innerHTML += htmlStr;  
};

var renderRowFillFn = function(el, row, width, offset, globals) {
  var xPos = (offset * globals.box_width) + globals.box_inner_padding;
  var yPos = ((row - 1) * (globals.box_height + globals.row_space)) + globals.box_inner_padding;
  var boxWidth = globals.box_width - globals.box_inner_padding * 2;
  var boxHeight = globals.box_height - globals.box_inner_padding * 2;
  var htmlStr = '';
  for (var i = 0; i < width; i++) {
    htmlStr += '<rect x="' + xPos + '" y="' + yPos + '" width="' + boxWidth + '" height="' + boxHeight + '" style="fill:rgb(138,159,236);" rx="5" ry="5" />';
    xPos += globals.box_width;
  }
  el.innerHTML += htmlStr;  
};

var renderFlowFn = function (el, row, width1, width2, offset1, offset2, globals) {
  var htmlStr = '';

  var xPos1_1 = offset1 * globals.box_width;
  var xPos1_2 = xPos1_1 + (globals.box_width * width1);
  var xPos2_1 = offset2 * globals.box_width;
  var xPos2_2 = xPos2_1 + (globals.box_width * width2);
  var yPos1 = ((row - 1) * (globals.box_height + globals.row_space)) + globals.box_height;
  var yPos2 = ((row - 0) * (globals.box_height + globals.row_space));

  htmlStr += '<path stroke="#8a9fec" d="M' + xPos1_1 + ' ' + yPos1 + ' C ' + xPos1_1 + ' ' + (yPos1 + 50) + ', ' + xPos2_1 + ' ' + (yPos2 - 50) + ', ' + xPos2_1 + ' ' + yPos2 + ' L' + xPos2_2 +' ' + yPos2 + ' C ' + xPos2_2 + ' ' + (yPos2 - 50) + ', ' + xPos1_2 + ' ' + (yPos1 + 50) + ', ' + xPos1_2 + ' ' + yPos1 + ' Z" opacity="0.5" fill-opacity="null" stroke-opacity="null" stroke-width="' + globals.stroke_width + '" fill="rgb(224,234,250)"/>';

  el.innerHTML += htmlStr;  
};


renderRowFn(svgEl, 1, 3, 3, globals);
renderRowFillFn(svgEl, 1, 3, 3, globals);
//renderFlowFn(svgEl, 1, 3, 1, 1, 1, globals);
//renderFlowFn(svgEl, 1, 5, 1, 1, 7, globals);

renderRowFn(svgEl, 2, 3, 3, globals);

function redoRendering() {
  var k1 = parseInt(document.getElementById("slider_k1").value);
  document.getElementById("value_k1").innerText = k1;
  var p1 = parseInt(document.getElementById("slider_p1").value);
  document.getElementById("value_p1").innerText = p1;
  var s1 = parseInt(document.getElementById("slider_s1").value);
  document.getElementById("value_s1").innerText = s1;
  var k2 = parseInt(document.getElementById("slider_k2").value);
  document.getElementById("value_k2").innerText = k2;
  var p2 = parseInt(document.getElementById("slider_p2").value);
  document.getElementById("value_p2").innerText = p2;
  var s2 = parseInt(document.getElementById("slider_s2").value);
  document.getElementById("value_s2").innerText = s2;

  document.getElementById("svg").innerHTML = "";
  renderRowFn(svgEl, 1, 3, 3, globals);
  
  var r0_width = 3;
  var r0_spacing = 3;
  var r0 = (r0_width + 2 * p1);

  var r1_width = Math.ceil((r0-(k1-1))/s1);
  var r1_spacing = Math.max(0, r0_spacing - Math.ceil((r1_width - r0_width)/2));
  for (var i=0, j=0; i+k1-1 < r0; i += s1, j++) {
    //var renderFlowFn = function (el, row, width1, width2, offset1, offset2, globals) {
    renderFlowFn(svgEl, 1, k1, 1, r0_spacing-p1+i, r1_spacing+j, globals);
  } 
  renderRowFn(svgEl, 2, r1_width, r1_spacing, globals);

  var r1 = (r1_width + 2 * p2);
  var r2 = Math.ceil((r1-(k2-1))/s2);
  var r2_width = r2;
  var r2_spacing = Math.max(0, r1_spacing - Math.ceil((r2_width - r1_width)/2));
  for (var i=0, j=0; i+k2-1 < r1; i += s2, j++) {
    //var renderFlowFn = function (el, row, width1, width2, offset1, offset2, globals) {
    renderFlowFn(svgEl, 2, k2, 1, r1_spacing-p2+i, r2_spacing+j, globals);
  } 
  renderRowFn(svgEl, 3, r2_width, r2_spacing, globals);
};

var nodes = document.querySelectorAll("input");
for (var i = 0; i < nodes.length; i++) {
  nodes[i].setAttribute("onchange", "redoRendering();");
}

redoRendering();

</script>

</body>
</html>
